<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    
  
    
      <link rel="canonical" href="https://blog.hongminhee.org/2010/10/12/fexpr/">
      <meta property="og:url" content="https://blog.hongminhee.org/2010/10/12/fexpr/">
    
  
  
  <meta name="description" value="">
  <meta name="twitter:card" content="summary">
  <meta property="og:locale" content="ko_KR">
  <meta property="og:site_name" content="洪民憙 블로그">
  <meta property="og:type" content="article">
  
    <meta name="twitter:title" content="Fexpr">
    <meta property="og:title" content="Fexpr">
  
  <meta name="twitter:description" content="Fexpr이란 (Lisp에서) 적용될 때 인자들을 모두 평가한 결과 값을 전달받는 대신, 인자에 나열된 폼들(forms)을 그대로 전달받는 함수를 말한다. 따라서 인자는 아무 것도 평가되지 않을 수도 있고, 평가 순서가 달라질 수도 있다. 함수 안쪽에서 폼을 가지고 명시적으로 평가(eval 함수를 이용해서)해야 하므로 Haskell 등에서 사용하는 normal order evaluation과도 다른 이야기다. …">
  <meta property="og:description" content="Fexpr이란 (Lisp에서) 적용될 때 인자들을 모두 평가한 결과 값을 전달받는 대신, 인자에 나열된 폼들(forms)을 그대로 전달받는 함수를 말한다. 따라서 인자는 아무 것도 평가되지 않을 수도 있고, 평가 순서가 달라질 수도 있다. 함수 안쪽에서 폼을 가지고 명시적으로 평가(eval 함수를 이용해서)해야 하므로 Haskell 등에서 사용하는 normal order evaluation과도 다른 이야기다. …">
  <meta property="og:updated_time"
        content="2010-10-12T10:48:00+09:00">
  
      <title>Fexpr &mdash; 洪民憙 블로그</title>
      <link rel="alternate" type="application/atom+xml" title="洪民憙 블로그"
            href="https://blog.hongminhee.org/feed.xml">
      <meta name="author" content="홍민희">
      <link rel="stylesheet" media="screen"
            href="https://blog.hongminhee.org/static/style.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-jp.css">
      <meta name="viewport" content="width=device-width, user-scalable=no">
      <meta name="twitter:creator" content="@hongminhee">
      <meta name="twitter:site" content="@hongminhee">
      <meta property="article:author"
            content="https://www.facebook.com/hongminhee">
    

  </head>
  <body class=" post-page outdated">
    
  
      <header>
        
          <a href="https://blog.hongminhee.org/index.html" class="site-name">
              <ruby>洪民憙 <rp>(</rp><rt>홍민희</rt><rp>)</rp></ruby>
              블로그
            </a>
          <nav>
            <a href="https://hongminhee.org/" rel="author me">본인 소개</a>
            <div class="archive">
              아카이브:
              <ul>
                
                  <li><a href="https://blog.hongminhee.org/2017/">2017</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2016/">2016</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2015/">2015</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2014/">2014</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2013/">2013</a></li>
                
              </ul>
            </div>
          </nav>
        
      </header>

      <ul class="disclaimer">
        <li>글을 썼을 당시의 주장에 제 스스로가 더이상 동의하지 못하는
            경우도 있습니다.</li>
        <li>심지어 몇몇 글은 이제 정 반대의 의견을 가지고 있기도 합니다.</li>
        <li>지금까지 여러 주제에 대한 의견이 꾸준히 달라졌습니다.
            앞으로도 그럴 것입니다.</li>
        <li>따라서 제 생각을 바꾸기 위한 설득도 환영합니다.
            저는 의견을 바꿀 의향이 있습니다.</li>
      </ul>
    

  <article>
    
      <time datetime="2010-10-12T10:48:00+09:00">2010년 10월 12일</time>
    

    
      
  <p class="outdate-disclaimer">
    이하의 글은 2010년에 쓴 것입니다. 오래된 글인 만큼, 현재의
    생각과 전혀 다른 내용도 많이 포함되어 있고, 당시와는 상황이 많이 달라진
    점도 있습니다. 또한, 그 당시에 잘못 알려졌던 정보도 포함되어 있을 수
    있습니다. <em>어찌됐든 저는 제 오래된 글이 회자되는 것을 저어합니다.</em>
    읽기에 앞서 양해를 부탁드립니다.
  <p>
        <h1 id="fexprsource"><a href="http://en.wikipedia.org/wiki/Fexpr">Fexpr</a></h1>
<p>Fexpr이란 (Lisp에서) 적용될 때 인자들을 모두 평가한 결과 값을 전달받는 대신, 인자에 나열된 폼들(forms)을 그대로 전달받는 함수를 말한다.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 따라서 인자는 아무 것도 평가되지 않을 수도 있고, 평가 순서가 달라질 수도 있다. 함수 안쪽에서 폼을 가지고 명시적으로 평가(<code>eval</code> 함수를 이용해서)해야 하므로 Haskell 등에서 사용하는 <a href="http://en.wikipedia.org/wiki/Normal_order_evaluation#Normal_order">normal order evaluation</a>과도 다른 이야기다.</p>
<p>Lisp은 아니지만 <a href="http://iolanguage.com/">Io</a>나 내가 만드려는 언어인 Veeyu도 fexpr 기능을 갖고 있다.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>그야 물론 Lisp의 모든 폼이 사실은 리스트(list) 아니면 애텀(atom)이라는 homoiconicity 덕분에 가능한 이야기다.<a href="#fnref1">↩</a></p></li>
</ol>
</section>

        <script>
        (function () {
          var ps = document.getElementsByClassName('outdate-disclaimer');
          if (ps.length < 1) {
            return;
          }
          var p = ps[0], t = document.createElement('span');
          t.addEventListener('click', function () {
            this.parentNode.removeChild(this);
            var gs = document.getElementsByClassName('outdate-gray-out');
            for (var i = gs.length - 1; i >= 0; --i) {
              gs[i].className = gs[i].className.replace(
                /(^|\s)outdate-gray-out(\s|$)/g, '');
            }
          });
          t.className = 'toggler';
          t.innerText = '읽기';
          p.appendChild(t);
          var e = p.nextSibling;
          while (e !== null && e !== undefined) {
            if (e.nodeType === 1) {
              e.className += ' outdate-gray-out';
            }
            e = e.nextSibling;
          }
        })();
        </script>
      
    
  </article>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-54324071-2', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>



