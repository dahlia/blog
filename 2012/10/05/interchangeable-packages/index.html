<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    
  
    
      <link rel="canonical" href="https://blog.hongminhee.org/2012/10/05/interchangeable-packages/">
      <meta property="og:url" content="https://blog.hongminhee.org/2012/10/05/interchangeable-packages/">
    
  
  
  <meta name="description" value="">
  <meta name="twitter:card" content="summary">
  <meta property="og:locale" content="ko_KR">
  <meta property="og:site_name" content="洪民憙 블로그">
  <meta property="og:type" content="article">
  
    <meta name="twitter:title" content="Interchangeable packages">
    <meta property="og:title" content="Interchangeable packages">
  
  <meta name="twitter:description" content="(배경 설명이 길어서 본론이 좀 밑에서부터 시작합니다.) …">
  <meta property="og:description" content="(배경 설명이 길어서 본론이 좀 밑에서부터 시작합니다.) …">
  <meta property="og:updated_time"
        content="2012-10-05T07:29:00+09:00">
  
      <title>Interchangeable packages &mdash; 洪民憙 블로그</title>
      <link rel="alternate" type="application/atom+xml" title="洪民憙 블로그"
            href="https://blog.hongminhee.org/feed.xml">
      <meta name="author" content="홍민희">
      <link rel="stylesheet" media="screen"
            href="https://blog.hongminhee.org/static/style.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-jp.css">
      <meta name="viewport" content="width=device-width, user-scalable=no">
      <meta name="twitter:creator" content="@hongminhee">
      <meta name="twitter:site" content="@hongminhee">
      <meta property="article:author"
            content="https://www.facebook.com/hongminhee">
    

  </head>
  <body class=" post-page">
    
  
      <header>
        
          <a href="https://blog.hongminhee.org/index.html" class="site-name">
              <ruby>洪民憙 <rp>(</rp><rt>홍민희</rt><rp>)</rp></ruby>
              블로그
            </a>
          <nav>
            <a href="https://hongminhee.org/" rel="author me">본인 소개</a>
            <div class="archive">
              아카이브:
              <ul>
                
                  <li><a href="https://blog.hongminhee.org/2017/">2017</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2016/">2016</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2015/">2015</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2014/">2014</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2013/">2013</a></li>
                
              </ul>
            </div>
          </nav>
        
      </header>

      <ul class="disclaimer">
        <li>글을 썼을 당시의 주장에 제 스스로가 더이상 동의하지 못하는
            경우도 있습니다.</li>
        <li>심지어 몇몇 글은 이제 정 반대의 의견을 가지고 있기도 합니다.</li>
        <li>지금까지 여러 주제에 대한 의견이 꾸준히 달라졌습니다.
            앞으로도 그럴 것입니다.</li>
        <li>따라서 제 생각을 바꾸기 위한 설득도 환영합니다.
            저는 의견을 바꿀 의향이 있습니다.</li>
      </ul>
    

  <article>
    
      <time datetime="2012-10-05T07:29:00+09:00">2012년 10월 5일</time>
    

    
      <h1 id="interchangeable-packages">Interchangeable packages</h1>
<p>(배경 설명이 길어서 본론이 좀 밑에서부터 시작합니다.)</p>
<p>이미 있는 유명한 라이브러리의 인터페이스만 맞추고서 내부 구현은 다른 (보통 성능 향상 등을 위해 새로 작성한) 라이브러리들이 있다. 예를 들어 libjpeg의 인터페이스를 맞추고 성능을 끌어올린 libjpeg-turbo 같은 것이 그런 것인데, 이럴 때 보통 <q>libjpeg-turbo는 libjpeg의 drop-in replacement다</q>라는 표현을 쓴다. 한국어로는 해당하는 단어가 뭐가 있을지 잘 모르겠다.</p>
<p>Python에서도 비슷한 것들이 있는데, 예를 들어 JSON 구현체들이 그렇다. Python 2.6에 추가된 표준 라이브러리에 <code>json</code> 모듈이 있는데 이 모듈은 매우 간단한 인터페이스로 구성되어 있다. <code>load()</code>, <code>loads()</code>, <code>dump()</code>, <code>dumps()</code> 이렇게 4개의 함수를 제공하는 모듈이다.</p>
<p>그런데 이 표준 <code>json</code> 모듈과 같은 인터페이스로 성능에 촛점을 맞춰 서로 경쟁적으로 구현된 서드파티 라이브러리들이 꽤 된다. 가장 유명한 것으로는 <code>simplejson</code>이 있고, 또 <code>ujson</code>이라는 것도 있다. 지금은 Python 2.7 런타임을 제공하지만 Google App Engine이 작년까지도 Python 2.5 런타임만 제공하여 표준 라이브러리의 <code>json</code>을 쓸 수 없었을 때, SDK에 내장된 <code>django.utils.simplejson</code> 모듈을 사용해야 했다. 현재 가장 최근 버전의 Jython인 Jython 2.5 역시 표준 라이브러리에 <code>json</code>이 없으므로 서드파티 라이브러리인 Jyson에 들어있는 <code>com.xhaus.jyson.JysonCodec</code>를 써야 한다.</p>
<p>종합해서, 사용할 수 있는 가장 좋은 성능의 JSON 모듈을 쓰면서도, 가장 이식성이 높은 코드를 쓰기 위해 다음과 같은 긴 <code>try</code>–<code>except</code>–<code>import</code> 패턴을 써야 한다.</p>
<pre><code>try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        try:
            from django.utils import simplejson as json
        except ImportError:
            try:
                from com.xhaus.jyson import JysonCodec as json
            except ImportError:
                import json</code></pre>
<p>만약 Python에서 위와 같은 패턴을 지원하는 문법을 별도로 지원하고자 한다면 다음과 같은 것이 필요할 것이다.</p>
<pre><code>import (ujson or simplejson or django.utils.simplejson or
        com.xhaus.jyson.JysonCodec or json) as json</code></pre>
<p>한편, 저런 식으로 인터페이스가 호환되는 서로 다른 구현체가 존재하는 모듈들이 JSON만 있는 것은 아니다. 예를 들어 <code>ElementTree</code>라는 XML 파서 인터페이스와 호환되는 것만 표준의 <code>xml.etree.ElementTree</code>, <code>xml.etree.cElementTree</code>, 서드파티 libxml2 바인딩인 <code>lxml.etree</code> 등이 있다.</p>
<p>여기서부터가 본론이다.</p>
<p>그런데 객체의 중립적인 인터페이스는 형식(할 수 있는 것)에 대해서는 합의하는 반면 시멘틱(해야할 것)에 대해서는 불가지론적(agnostic)인데, 반면 모듈의 중립적인 인터페이스는 시멘틱에 대해서도 합의한다는 차이점이 있다.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 그래서 오래전부터 생각한 아이디어가 두 개 있다. 이 두 아이디어는 하나의 시스템으로 통합될 수도 있다.</p>
<p>첫번째 아이디어는 이렇다. 현재의 모듈 인터페이스는 C++의 템플릿 시그너쳐나 덕 타입 언어의 객체 인터페이스처럼 암시적으로 <q>생겨나는</q> 것이다. 이와 같은 종류의 합의는 합의가 변해야 할 시점이 오면 큰 문제가 생기게 된다. 즉, 실제 구현체가 어떤 인터페이스에 의도적으로 합의했는지 알 수 없으므로 어떤 종류의 전후처리도 불가능하거나 힘들게 한다. 그래서 C++0x 얘기가 오갈 때 Haskell의 타입클래스를 배낀 <a href="http://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29">컨셉</a>(concepts)을 도입하자는 주장이 있었던 것이다. 하지만 모듈 인터페이스에 있어서 더 중요한 것은, <strong>선언 없이는 구현체가 인터페이스에 합의하는지는 알 수 있지만 인터페이스에 합의하는 모든 구현체를 찾는 일은 할 수 없다는 점이다.</strong></p>
<p>따라서 <strong>중립적인 모듈 인터페이스 역시 선언적(declarative)이어야 한다.</strong> 즉, 인터페이스의 선언이 존재하고, 구현체가 그 인터페이스에 합의한다는 선언도 존재해야 한다. 그렇게 되면 언어의 패키지 시스템은 모듈을 구현체 이름으로 임포트할 수 있을 뿐만 아니라, 선언된 중립적인 모듈 인터페이스로도 임포트할 수 있을 것이다. 예를 들어,</p>
<pre><code>from xml.etree import cElementTree as etree</code></pre>
<p>라고 하거나, (가상의 문법으로 예를 들자면)</p>
<pre><code>import (lxml.etree or xml.etree.cElementTree or xml.etree.ElementTree) as etree</code></pre>
<p>라고 하는 대신 (선언된 모듈 인터페이스 이름이 <code>etree</code>라고 할 때) 다음과 같이 임포트할 수 있을 것이다.</p>
<pre><code>import etree</code></pre>
<p>좀더 나아가자면, 모듈 인터페이스는 구현체의 다양한 관점의 효과성이나 효율성, 기능성 등에 대해서도 매개변수를 선언할 수 있고, 임포트 시에는 특정 매개변수를 기준으로 선호하는 구현체가 적절히 선택되도록 할 수 있을지도 모른다.</p>
<pre><code>import etree:
    less node_memory_use
    more maximum_child_depth
    if html_parseable
    unless c_used</code></pre>
<p>두번째 아이디어는 첫번째 아이디어에 의존적이다. 중립적인 모듈 인터페이스가 선언적이고, 앞서 내가 제시한 가설과 같이 모듈 인터페이스에는 객체 인터페이스와 달리 모듈이 할 수 있는 일(형식) 뿐만 아니라 해야할 일(시멘틱)에 대해서도 합의한다면, <strong>시멘틱을 검증할 수 있는 수단을 함께 선언할 수 있어야 할 것이다.</strong> 그리고 내 생각에 <strong>시멘틱은 자동화된 테스트로 검증할 수 있다.</strong></p>
<p>즉, 중립적인 모듈 인터페이스는 특정 대상 구현체를 상정하지 않은 테스트를 포함할 수 있을 것이다. 앞서 예로 든 JSON 모듈의 경우를 생각해보자. 각자 다른 구현체이지만, 인터페이스도 같고 하는 일도 같다. 즉, 시멘틱을 공유한다. 같은 JSON을 파싱하면 각 구현체는 어쨌든 같은 Python 객체를 반환해야 한다.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> 같은 Python 객체를 직렬화하면 같은 JSON이 나와야 한다. <strong>즉, 테스트 케이스는 공유할 수 있다.</strong></p>
<p>Markdown 구현체를 생각해보자. <a href="http://six.pairlist.net/pipermail/markdown-discuss/2004-December/000909.html">Markdown은 표준적인 테스트 스위트가 있다.</a> 이게 모듈 인터페이스의 테스트가 될 수 있다. Markdown 인터페이스를 구현하는 모듈은 자체적인 테스트를 포함할 수 있지만, 중립적인 모듈 인터페이스의 표준 테스트도 함께 통과해야 한다.</p>
<p>이런 예는 너무 많기 때문에 쉽게 열거할 수 있다. WSGI 서버, XML 파서, 마크업 언어 번역기, diff, 이미지 처리 등…</p>
<p>요약하자면 이렇게 된다. 모듈에는 인터페이스와 구현체가 있을 수 있다. 인터페이스는 선언과 테스트가 들어간다. 구현체에는 테스트를 통과하는 구현체가 들어간다. 패키지 시스템은 모듈을 인터페이스 혹은 특정 구현체 이름으로 임포트할 수 있다. 인터페이스는 매개변수를 포함할 수도 있으며, 구현체는 매개변수에 적절한 값을 제공하고, 임포트 시에 매개변수를 이용해 세밀한 조건을 제시할 수 있다.</p>
<p>내가 언어를 만들게 되면 패키지 시스템을 이렇게 만들 생각이다.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>그렇지 않은 모듈 인터페이스도 있다. 가령 위에서 소개한 <code>load()</code>, <code>loads()</code>, <code>dump()</code>, <code>dumps()</code> 네 개의 함수로 이루어진 JSON 모듈 인터페이스는 사실 JSON 모듈 인터페이스이기 전에 Python의 표준적인 직렬화 모듈 인터페이스다. <code>pickle</code>, <code>cPickle</code>, <code>marshal</code> 등 Python의 많은 직렬화 모듈들이 오래전부터 이 인터페이스로 합의해왔고, JSON도 직렬화 방식이기 때문에 원래부터 있던 인터페이스를 따른 것뿐이다. 하지만 저 직렬화 모듈들은 서로 다른 직렬화 포맷이고 기능도 상이하다. 물론 저 모듈들 사이에서도 <code>loads(dumps(value)) == value</code> 같은 최소한의 시멘틱은 존재할 수 있다.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>코드로 얘기하자면 <code>json</code> 모듈이 실제 어떤 구현체를 지칭하든 간에, 구현체는 항상 <code>json.dumps(range(3)) == '[0, 1, 2]'</code>를 만족해야 한다.<a href="#fnref2">↩</a></p></li>
</ol>
</section>

    
  </article>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-54324071-2', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>



