<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    
  
    
      <link rel="canonical" href="https://blog.hongminhee.org/2012/02/22/18011842515/">
      <meta property="og:url" content="https://blog.hongminhee.org/2012/02/22/18011842515/">
    
  
  
  <meta name="description" value="">
  <meta name="twitter:card" content="summary">
  <meta property="og:locale" content="ko_KR">
  <meta property="og:site_name" content="洪民憙 블로그">
  <meta property="og:type" content="article">
  
  <meta name="twitter:description" content=".NET을 쓰는 대부분의 개발자들의 문제는 자신이 쓰는 도구가 얼마나 강력한지 제대로 모르고 있다는 점이라고 생각한다. 대부분 MFC 개발하던 사람이어서 그런지 몰라도, 최근 C# 등에 추가되었던 최신 기술들이 사실은 현대적으로 잘 포장된 프로그래밍 언어의 주요 컨셉들이라는 점을 인식하지 못한다. 오히려 이전에 Common Lisp이라도 했던 사람들이면 표현식 트리가 사실 homoiconicity의 .NET판이라는 것을 알고, Haskell이나 Python을 했던 사람들이면 LINQ가 list comprehensions의 확장판이라는 것도 쉽게 알아차릴 수 있을 것이다. 애초에 CLR이라는 개념부터가 현재 JVM이 누리고 있는 ‘공용 언어 VM’ 역할을 의도(CLR을 풀어보면 ‘공용 언어 런타임’이다)한 것도 매우 앞선 것이었다. 그보다 몇년 뒤에 Parrot이 동적 언어들을 위한 CLR 같은 것을 노렸지만 제대로 대중화되지는 않았고, 몇년 뒤에 CLR의 하위 기술로 Parrot의 목표와 겹치는 DLR 같은 것이 나오기도 했다. P/Invoke 같은 것도 Python의 ctypes 같은 C FFI보다 훨씬 앞서 나온 거였는데 실상은 .NET 개발자들 사이에서 Win32 API에서만 쓸 수 있는 함수들 부르는 용도로밖에 안 쓰이는 것 같다. …">
  <meta property="og:description" content=".NET을 쓰는 대부분의 개발자들의 문제는 자신이 쓰는 도구가 얼마나 강력한지 제대로 모르고 있다는 점이라고 생각한다. 대부분 MFC 개발하던 사람이어서 그런지 몰라도, 최근 C# 등에 추가되었던 최신 기술들이 사실은 현대적으로 잘 포장된 프로그래밍 언어의 주요 컨셉들이라는 점을 인식하지 못한다. 오히려 이전에 Common Lisp이라도 했던 사람들이면 표현식 트리가 사실 homoiconicity의 .NET판이라는 것을 알고, Haskell이나 Python을 했던 사람들이면 LINQ가 list comprehensions의 확장판이라는 것도 쉽게 알아차릴 수 있을 것이다. 애초에 CLR이라는 개념부터가 현재 JVM이 누리고 있는 ‘공용 언어 VM’ 역할을 의도(CLR을 풀어보면 ‘공용 언어 런타임’이다)한 것도 매우 앞선 것이었다. 그보다 몇년 뒤에 Parrot이 동적 언어들을 위한 CLR 같은 것을 노렸지만 제대로 대중화되지는 않았고, 몇년 뒤에 CLR의 하위 기술로 Parrot의 목표와 겹치는 DLR 같은 것이 나오기도 했다. P/Invoke 같은 것도 Python의 ctypes 같은 C FFI보다 훨씬 앞서 나온 거였는데 실상은 .NET 개발자들 사이에서 Win32 API에서만 쓸 수 있는 함수들 부르는 용도로밖에 안 쓰이는 것 같다. …">
  <meta property="og:updated_time"
        content="2012-02-22T00:39:37+09:00">
  
      <title>2012년 2월 22일 &mdash; 洪民憙 블로그</title>
      <link rel="alternate" type="application/atom+xml" title="洪民憙 블로그"
            href="https://blog.hongminhee.org/feed.xml">
      <meta name="author" content="홍민희">
      <link rel="stylesheet" media="screen"
            href="https://blog.hongminhee.org/static/style.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-jp.css">
      <meta name="viewport" content="width=device-width, user-scalable=no">
      <meta name="twitter:creator" content="@hongminhee">
      <meta name="twitter:site" content="@hongminhee">
      <meta property="article:author"
            content="https://www.facebook.com/hongminhee">
    

  </head>
  <body class=" post-page outdated">
    
  
      <header>
        
          <a href="https://blog.hongminhee.org/index.html" class="site-name">
              <ruby>洪民憙 <rp>(</rp><rt>홍민희</rt><rp>)</rp></ruby>
              블로그
            </a>
          <nav>
            <a href="https://hongminhee.org/" rel="author me">본인 소개</a>
            <div class="archive">
              아카이브:
              <ul>
                
                  <li><a href="https://blog.hongminhee.org/2017/">2017</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2016/">2016</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2015/">2015</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2014/">2014</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2013/">2013</a></li>
                
              </ul>
            </div>
          </nav>
        
      </header>

      <ul class="disclaimer">
        <li>글을 썼을 당시의 주장에 제 스스로가 더이상 동의하지 못하는
            경우도 있습니다.</li>
        <li>심지어 몇몇 글은 이제 정 반대의 의견을 가지고 있기도 합니다.</li>
        <li>지금까지 여러 주제에 대한 의견이 꾸준히 달라졌습니다.
            앞으로도 그럴 것입니다.</li>
        <li>따라서 제 생각을 바꾸기 위한 설득도 환영합니다.
            저는 의견을 바꿀 의향이 있습니다.</li>
      </ul>
    

  <article>
    
      <h1><time datetime="2012-02-22T00:39:37+09:00">2012년 2월 22일</time></h1>
    

    
      
  <p class="outdate-disclaimer">
    이하의 글은 2012년에 쓴 것입니다. 오래된 글인 만큼, 현재의
    생각과 전혀 다른 내용도 많이 포함되어 있고, 당시와는 상황이 많이 달라진
    점도 있습니다. 또한, 그 당시에 잘못 알려졌던 정보도 포함되어 있을 수
    있습니다. <em>어찌됐든 저는 제 오래된 글이 회자되는 것을 저어합니다.</em>
    읽기에 앞서 양해를 부탁드립니다.
  <p>
        <p>.NET을 쓰는 대부분의 개발자들의 문제는 자신이 쓰는 도구가 얼마나 강력한지 제대로 모르고 있다는 점이라고 생각한다. 대부분 MFC 개발하던 사람이어서 그런지 몰라도, 최근 C# 등에 추가되었던 최신 기술들이 사실은 현대적으로 잘 포장된 프로그래밍 언어의 주요 컨셉들이라는 점을 인식하지 못한다. 오히려 이전에 Common Lisp이라도 했던 사람들이면 <a href="http://msdn.microsoft.com/en-us/library/bb397951.aspx">표현식 트리</a>가 사실 homoiconicity의 .NET판이라는 것을 알고, Haskell이나 Python을 했던 사람들이면 <a href="http://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a>가 list comprehensions의 확장판이라는 것도 쉽게 알아차릴 수 있을 것이다. 애초에 CLR이라는 개념부터가 현재 JVM이 누리고 있는 <q>공용 언어 VM</q> 역할을 의도(CLR을 풀어보면 ‘공용 언어 런타임’이다)한 것도 매우 앞선 것이었다. 그보다 몇년 뒤에 <a href="http://parrot.org/">Parrot</a>이 동적 언어들을 위한 CLR 같은 것을 노렸지만 제대로 대중화되지는 않았고, 몇년 뒤에 CLR의 하위 기술로 Parrot의 목표와 겹치는 DLR 같은 것이 나오기도 했다. P/Invoke 같은 것도 Python의 <code>ctypes</code> 같은 C FFI보다 훨씬 앞서 나온 거였는데<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 실상은 .NET 개발자들 사이에서 Win32 API에서만 쓸 수 있는 함수들 부르는 용도로밖에 안 쓰이는 것 같다.</p>
<p>결국 .NET은 CLR이라는 훌륭한 기술에도 불구하고 문화가 수준을 못 따라가는 느낌이다. 또다른 CLR 구현인 Mono 같은 경우에도 역시나 훌륭하지만 이쪽은 오픈소스 쪽에서 막연히<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> CLR이 Microsoft가 주도하는 표준이라 꺼려지는 상황이고.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>물론 그 이전에도 Common Lisp 등에서 비슷한 개념의 FFI가 있긴 했지만, .NET 같은 메이저 기술로 등장한 것은 처음이다.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>항상 막연한 것은 아니긴 하지만 내가 볼 때 대부분의 우려는 막연한 것이다.<a href="#fnref2">↩</a></p></li>
</ol>
</section>

        <script>
        (function () {
          var ps = document.getElementsByClassName('outdate-disclaimer');
          if (ps.length < 1) {
            return;
          }
          var p = ps[0], t = document.createElement('span');
          t.addEventListener('click', function () {
            this.parentNode.removeChild(this);
            var gs = document.getElementsByClassName('outdate-gray-out');
            for (var i = gs.length - 1; i >= 0; --i) {
              gs[i].className = gs[i].className.replace(
                /(^|\s)outdate-gray-out(\s|$)/g, '');
            }
          });
          t.className = 'toggler';
          t.innerText = '읽기';
          p.appendChild(t);
          var e = p.nextSibling;
          while (e !== null && e !== undefined) {
            if (e.nodeType === 1) {
              e.className += ' outdate-gray-out';
            }
            e = e.nextSibling;
          }
        })();
        </script>
      
    
  </article>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-54324071-2', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>



