<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    
  
    
      <link rel="canonical" href="https://blog.hongminhee.org/2013/10/30/65522658529/">
      <meta property="og:url" content="https://blog.hongminhee.org/2013/10/30/65522658529/">
    
  
  
  <meta name="description" value="">
  <meta name="twitter:card" content="summary">
  <meta property="og:locale" content="ko_KR">
  <meta property="og:site_name" content="洪民憙 블로그">
  <meta property="og:type" content="article">
  
    <meta name="twitter:title" content="SQLAlchemy에서 쿼리할 때 조인을 직접 명시해야 하는 경우는 별로 없다">
    <meta property="og:title" content="SQLAlchemy에서 쿼리할 때 조인을 직접 명시해야 하는 경우는 별로 없다">
  
  <meta name="twitter:description" content="오랜만에 특정 라이브러리의 세부사항에 대해 얘기해본다. …">
  <meta property="og:description" content="오랜만에 특정 라이브러리의 세부사항에 대해 얘기해본다. …">
  <meta property="og:updated_time"
        content="2013-10-30T23:00:12+09:00">
  
      <title>SQLAlchemy에서 쿼리할 때 조인을 직접 명시해야 하는 경우는 별로 없다 &mdash; 洪民憙 블로그</title>
      <link rel="alternate" type="application/atom+xml" title="洪民憙 블로그"
            href="https://blog.hongminhee.org/feed.xml">
      <meta name="author" content="홍민희">
      <link rel="stylesheet" media="screen"
            href="https://blog.hongminhee.org/static/style.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css">
      <link rel="stylesheet" type="text/css"
        href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-jp.css">
      <meta name="viewport" content="width=device-width, user-scalable=no">
      <meta name="twitter:creator" content="@hongminhee">
      <meta name="twitter:site" content="@hongminhee">
      <meta property="article:author"
            content="https://www.facebook.com/hongminhee">
    

  </head>
  <body class=" post-page">
    
  
      <header>
        
          <a href="https://blog.hongminhee.org/index.html" class="site-name">
              <ruby>洪民憙 <rp>(</rp><rt>홍민희</rt><rp>)</rp></ruby>
              블로그
            </a>
          <nav>
            <a href="https://hongminhee.org/" rel="author me">본인 소개</a>
            <div class="archive">
              아카이브:
              <ul>
                
                  <li><a href="https://blog.hongminhee.org/2017/">2017</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2016/">2016</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2015/">2015</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2014/">2014</a></li>
                
                  <li><a href="https://blog.hongminhee.org/2013/">2013</a></li>
                
              </ul>
            </div>
          </nav>
        
      </header>

      <ul class="disclaimer">
        <li>글을 썼을 당시의 주장에 제 스스로가 더이상 동의하지 못하는
            경우도 있습니다.</li>
        <li>심지어 몇몇 글은 이제 정 반대의 의견을 가지고 있기도 합니다.</li>
        <li>지금까지 여러 주제에 대한 의견이 꾸준히 달라졌습니다.
            앞으로도 그럴 것입니다.</li>
        <li>따라서 제 생각을 바꾸기 위한 설득도 환영합니다.
            저는 의견을 바꿀 의향이 있습니다.</li>
      </ul>
    

  <article>
    
      <time datetime="2013-10-30T23:00:12+09:00">2013년 10월 30일</time>
    

    
      <h1 id="sqlalchemy에서-쿼리할-때-조인을-직접-명시해야-하는-경우는-별로-없다">SQLAlchemy에서 쿼리할 때 조인을 직접 명시해야 하는 경우는 별로 없다</h1>
<p>오랜만에 특정 라이브러리의 세부사항에 대해 얘기해본다.</p>
<p>SQLAlchemy ORM을 쓰는 경우 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/query.html#sqlalchemy.orm.query.Query.join"><code>Query.join()</code></a> 메서드를 직접 써야 하는 경우는 사실 별로 없다. 대부분은 기능을 다 알지 못해서 그렇게 쓰는 것이다.</p>
<p>참고로 이 글에서 다루는 내용은 원래 SQLAlchemy 공식 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/tutorial.html">튜토리얼</a>과 가이드 문서의 (API 레퍼런스 말고) <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/loading.html">관계 로딩 테크닉</a> 부분에서 훨씬 더 자세히 설명되어 있다.</p>
<h2 id="로딩하면서-관계-객체들도-한번에-같이-가져오고-싶을-때">로딩하면서 관계 객체들도 한번에 같이 가져오고 싶을 때</h2>
<p><code>Query.join()</code> 메서드를 잘못 사용하는 첫번째 케이스는 관계된 객체들까지 함께 eager loading하고 싶을 때이다.</p>
<pre><code>session.query(Post) \
       .join(User, Post.author_id == User.id)</code></pre>
<p>하지만 위와 같이 써서는 원하는대로 작동하지 않는다. 실제로 <code>Post.author</code> 속성에 접근할 때 별도의 쿼리가 따로 나갈 것이다.</p>
<p>그 이전에 위 쿼리는 스타일 상으로도 문제가 있다. 모델 정의 시에 어차피 <code>Post.author</code> 관계 속성에 조인 조건을 명시하거나 자동으로 추론되는데, 해당 조건을 쿼리할 때 중복해서 다시 쓰는 것이다. 이렇게 되면 추후 관계 조건이 달라졌을 때 쿼리 코드를 뒤져가며 함께 고쳐줘야 하는 문제가 생긴다. (십중팔구는 까먹고 안 고쳤다가 논리적인 오류를 만난다.)</p>
<p>일단 중복 문제만 개선하자면 다음과 같이 고칠 수 있다.</p>
<pre><code>session.query(Post).join(Post.author)</code></pre>
<p>보다시피 <code>Query.join()</code> 메서드는 관계 속성 자체를 인자로 받는다. 이렇게 하면 나중에 <code>Post.author</code>의 조건이 달라졌을 때도 의미가 변하지 않을 것이다.</p>
<p>하지만 여전히 <code>Post.author</code> 속성에 접근했을 때 별도 쿼리가 생성되는 문제는 존재한다. 왜냐면 SQLAlchemy에서 쿼리 생성과 로딩 전략은 별도로 취급되기 때문이다. 조인된 <code>Post.author</code>를 메모리 상의 <code>Post</code> 객체를 만들 때 채워주고 싶다면 다음과 같이 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/query.html#sqlalchemy.orm.query.Query.options"><code>Query.options()</code></a> 메서드에 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/loading.html#sqlalchemy.orm.contains_eager"><code>contains_eager()</code></a>를 명시해야 한다.</p>
<pre><code>session.query(Post) \
       .join(Post.author) \
       .options(contains_eager(Post.author))</code></pre>
<p>이제 <code>Post.author</code> 속성에도 이미 메모리 상에 로딩된 <code>User</code> 객체가 들어가 있을 것이다.</p>
<p>하지만 굳이 <code>contains_eager()</code>를 쓸 필요 없이, <code>Query.join()</code>과 <code>contains_eager()</code>를 함께 해주는 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/loading.html#sqlalchemy.orm.joinedload"><code>joinedload()</code></a>를 쓰는 편이 낫다.</p>
<pre><code>session.query(Post).options(joinedload(Post.author))</code></pre>
<h2 id="조건-절에-조인된-테이블의-필드를-참조해야-하는-경우">조건 절에 조인된 테이블의 필드를 참조해야 하는 경우</h2>
<p><code>Query.join()</code> 메서드를 쓰는 또다른 경우는 조건 절에서 다른 관계된 테이블의 특정 컬럼을 참조해야 하는 경우이다.</p>
<pre><code>session.query(Post) \
       .join(User, User.id == Post.author_id) \
       .filter(~User.deleted) \
       .filter(User.last_login_time &gt; now() - datetime.timedelta(days=1))</code></pre>
<p>앞서 설명했듯 조인 조건을 굳이 중복해서 쓸 필요가 없으므로 위 쿼리도 다음과 같이 개선할 수 있다.</p>
<pre><code>session.query(Post) \
       .join(Post.author) \
       .filter(~User.deleted) \
       .filter(User.last_login_time &gt; now() - datetime.timedelta(days=1))</code></pre>
<p><a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/query.html#sqlalchemy.orm.query.Query.filter"><code>Query.filter()</code></a> 메서드 안에서 관계된 다른 모델의 속성을 참조해야 하는 경우, has-one 관계인 경우 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.has"><code>.has()</code></a> 메서드, has-many 관계인 경우 <a href="http://docs.sqlalchemy.org/en/rel_0_8/orm/internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any"><code>.any()</code></a> 메서드를 써서 표현할 수 있다.</p>
<pre><code>session.query(Post) \
       .filter(Post.author.has(
           ~User.deleted |
           (User.last_login_time &gt; now() - datetime.timedelta(days=1))
       ))</code></pre>
<p>단순 <code>==</code> 연산만 필요한 경우에는 아예 키워드 인자로 넘겨버려도 된다. 가령 아래 두 쿼리는 같은 의미다.</p>
<pre><code>session.query(Post).filter(Post.author.has(~User.deleted))

session.query(Post).filter(Post.author.has(deleted=False))</code></pre>

    
  </article>


    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-54324071-2', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>



